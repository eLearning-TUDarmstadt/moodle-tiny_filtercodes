{"version":3,"file":"ui.min.js","sources":["../src/ui.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Commands for the plugin logic of the Moodle tiny_filtercodes plugin.\n *\n * @module     tiny_filtercodes\n * @author     Leon Camus\n * @copyright  2025 onwards Leon Camus\n * @license    https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {\n    isNull,\n    filtercodeMap,\n    regexTagStartEnd,\n    classFiltercode,\n    classFiltercodeBegin,\n    classFiltercodeEnd, classFiltercodeLevel, classFiltercodeLevels, classFiltercodeError\n} from \"./common\";\nimport {getHighlightCss} from \"./options\";\nimport {openArgumentModal} from \"./arguments\";\n\n/**\n * Marker to remember that the submit button was hit.\n * @type {boolean}\n * @private\n */\nlet _isSubmit = false;\n\n/**\n * @param {Text} node\n * @returns {Node[]}\n */\nconst replaceTextWithSpan = function(node) {\n    let input = node.textContent;\n    const output = [];\n    const echo = function(text) {\n        // If the last element is a text node, append the text to it.\n        if (output.length > 0 && output[output.length - 1].nodeType === Node.TEXT_NODE) {\n            output[output.length - 1].textContent += text;\n        } else {\n            output.push(document.createTextNode(text));\n        }\n    };\n\n    while (input.length > 0) {\n        // Search for the next filtercode start.\n        const start = input.search(regexTagStartEnd);\n        if (start >= 0) {\n            // Add the text before the filtercode key.\n            echo(input.substring(0, start));\n            // Trim the input to the start of the filtercode key.\n            input = input.substring(start);\n            // Get the group matches of the regex.\n            const match = input.matchAll(regexTagStartEnd).next().value;\n            const isClosing = !isNull(match[1]);\n            const key = match[2];\n            const args = match[3];\n            // Check if key is valid\n            const filtercode = filtercodeMap[key];\n            // If the filtercode is invalid\n            // The filtercode is closing but the filtercode has no closing tag.\n            // The filtercode is closing but has args.\n            if (isNull(filtercode) || (isClosing && !filtercode.around) || (isClosing && !isNull(args))) {\n                // Add the invalid filtercode as text.\n                echo(input.substring(0, match[0].length));\n            } else {\n                // Add the span tag for the filtercode.\n                if (isClosing) {\n                    output.push(filtercode.endSpan());\n                } else {\n                    output.push(filtercode.beginSpan(args ? match[3].replace(/^\\s+/, '').split(' ') : []));\n                }\n            }\n            // Trim the input to the end of the filtercode key.\n            input = input.substring(match[0].length);\n            continue;\n        }\n        if (output.length === 0) {\n            return [node]; // No filtercodes found, return the original node.\n        }\n        echo(input);\n        input = \"\";\n    }\n\n    return output;\n};\n\n/**\n * @param {HTMLElement} node\n */\nconst transformDomToSpan = function(node) {\n    let newchildren = [];\n    node.childNodes.forEach((child) => {\n        if (child.nodeType === Node.TEXT_NODE) {\n            newchildren.push(...replaceTextWithSpan(child));\n        } else {\n            if (child.nodeType !== Node.ELEMENT_NODE || !child.classList.contains(classFiltercode)) {\n                transformDomToSpan(child);\n            }\n            newchildren.push(child);\n        }\n    });\n    node.innerHTML = \"\";\n    newchildren.forEach((child) => {\n        node.appendChild(child);\n    });\n};\n\n/**\n * Convert {key args}, {key}, {/key} strings to spans, so we can style them visually.\n * @param {Editor} ed\n * @return {string}\n */\nexport const addVisualStyling = function(ed) {\n    let input = ed.getContent();\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(input, 'text/html');\n    const element = doc.body;\n    transformDomToSpan(element);\n    addVisualLevelIndicators(ed, element);\n    return element.innerHTML;\n};\n\n/**\n * @param {Editor} ed\n * @param {HTMLElement} el\n */\nexport const addVisualLevelIndicators = function(ed, el) {\n    const keyStack = [];\n    const spans = el.querySelectorAll(`.${classFiltercode}`);\n    for (const span of spans) {\n        classFiltercodeLevels\n            .filter((className) => span.classList.contains(className))\n            .forEach((className) => span.classList.remove(className));\n        // Remove the error class (we will re-add it if necessary later).\n        if (span.classList.contains(classFiltercodeError)) {\n            span.classList.remove(classFiltercodeError);\n        }\n\n        // Add begin tags to the stack.\n        if (span.classList.contains(classFiltercodeBegin)) {\n            keyStack.push(span);\n            continue;\n        }\n\n        // Ignore spans that are not begin or end tags.\n        if (!span.classList.contains(classFiltercodeEnd)) {\n            continue;\n        }\n\n        // Match end tags with begin tags.\n        const top = keyStack[keyStack.length - 1];\n        // If the top of the stack is not the corresponding to a begin-tag, then we have an imbalanced filtercode.\n        // We need to determine if the end tag is the correct one or if the begin-tag is missing.\n        if (isNull(top) || top.dataset.filtercodekey !== span.dataset.filtercodekey) {\n            // Check if there is a corresponding begin tag.\n            if (keyStack.find((begin) => begin.dataset.filtercodekey === span.dataset.filtercodekey)) {\n                // If the begin tag is found, remove all tags on top of it.\n                while (keyStack.length > 0\n                    && keyStack[keyStack.length - 1].dataset.filtercodekey !== span.dataset.filtercodekey) {\n                    // Remove the top of the stack and mark it as imbalanced.\n                    keyStack.pop().classList.add(classFiltercodeError);\n                }\n            } else {\n                // If the begin tag is not found, then mark the end tag as imbalanced.\n                span.classList.add(classFiltercodeError);\n                continue;\n            }\n        }\n        if (keyStack.length > 0) {\n            // If the top of the stack is the corresponding begin tag, then remove it.\n            keyStack.pop().classList.add(classFiltercodeLevel(keyStack.length));\n            span.classList.add(classFiltercodeLevel(keyStack.length));\n        } else {\n            span.classList.add(classFiltercodeError);\n        }\n    }\n    // If the stack is not empty, then we have an imbalanced filtercode.\n    for (const span of keyStack) {\n        span.classList.add(classFiltercodeError);\n    }\n};\n\n/**\n * @param {Editor} ed\n */\nexport const updateVisualLevelIndicators = function(ed) {\n    let keyStack = [];\n    for (const span of ed.dom.select(`.${classFiltercode}`)) {\n        classFiltercodeLevels\n            .filter((className) => span.classList.contains(className))\n            .forEach((className) => ed.dom.removeClass(span, className));\n        // Remove the error class (we will re-add it if necessary later).\n        if (span.classList.contains(classFiltercodeError)) {\n            ed.dom.removeClass(span, classFiltercodeError);\n        }\n\n        // Add begin tags to the stack.\n        if (span.classList.contains(classFiltercodeBegin)) {\n            keyStack.push(span);\n            continue;\n        }\n\n        // Match end tags with begin tags.\n        if (span.classList.contains(classFiltercodeEnd)) {\n            const top = keyStack[keyStack.length - 1];\n            // If the top of the stack is not the corresponding begin tag, then we have an imbalanced filtercode.\n            // We need to determine if the end tag is the correct one or if the begin tag is missing.\n            if (isNull(top) || top.dataset.filtercodekey !== span.dataset.filtercodekey) {\n                // Check if there is a corresponding begin tag.\n                if (keyStack.find((begin) => begin.dataset.filtercodekey === span.dataset.filtercodekey)) {\n                    // If the begin tag is found, remove all tags on top of it.\n                    while (keyStack.length > 0\n                        && keyStack[keyStack.length - 1].dataset.filtercodekey !== span.dataset.filtercodekey) {\n                        // Remove the top of the stack and mark it as imbalanced.\n                        ed.dom.addClass(keyStack.pop(), classFiltercodeError);\n                    }\n                } else {\n                    // If the begin tag is not found, then mark the end tag as imbalanced.\n                    ed.dom.addClass(span, classFiltercodeError);\n                    continue;\n                }\n            }\n            if (keyStack.length > 0) {\n                // If the top of the stack is the corresponding begin tag, then remove it.\n                ed.dom.addClass(keyStack.pop(), classFiltercodeLevel(keyStack.length));\n                ed.dom.addClass(span, classFiltercodeLevel(keyStack.length));\n            } else {\n                ed.dom.addClass(span, classFiltercodeError);\n            }\n        }\n    }\n    // If the stack is not empty, then we have an imbalanced filtercode.\n    for (const span of keyStack) {\n        ed.dom.addClass(span, classFiltercodeError);\n    }\n};\n\n/**\n * When loading the editor for the first time, add the spans for highlighting the lang tags.\n * These are highlighted with the appropriate css only.\n * @param {Editor} ed\n */\nexport const onInit = function(ed) {\n    ed.setContent(addVisualStyling(ed));\n    ed.dom.addStyle(getHighlightCss(ed));\n};\n\n/**\n * Remove the spans we added in addVisualStyling() to leave only the {xxx} tags.\n * @param {Editor} ed\n */\nexport const removeVisualStyling = function(ed) {\n    for (const span of ed.dom.select(`.${classFiltercode}`)) {\n        ed.dom.setOuterHTML(span, span.innerHTML);\n    }\n    // Save to textarea.\n    ed.save();\n};\n\n/**\n * When the submit button is hit, the marker spans are removed. However, if there's an error\n * in saving the content (via ajax) the editor remains with the cleaned content. Therefore,\n * we need to add the marker span elements once again when the user tries to change the content\n * of the editor.\n * @param {Editor} ed\n */\nexport const onFocus = function(ed) {\n    if (_isSubmit) {\n        // eslint-disable-next-line camelcase\n        ed.setContent(addVisualStyling(ed), {no_events: true});\n        _isSubmit = false;\n    }\n};\n\n/**\n * Fires when the form containing the editor is submitted. Remove all the marker span elements.\n * @param {Editor} ed\n */\nexport const onSubmit = function(ed) {\n    removeVisualStyling(ed);\n    _isSubmit = true;\n};\n\n/**\n * When the source code view dialogue is show, we must remove the highlight spans from the editor content\n * and also add them again when the dialogue is closed.\n * @param {Editor} ed\n * @param {object} content\n */\nexport const onBeforeGetContent = function(ed, content) {\n    if (!isNull(content.source_view) && content.source_view === true) {\n        // If the user clicks on 'Cancel' or the close button on the html\n        // source code dialog view, make sure we re-add the visual styling.\n        const onClose = function(ed) {\n            ed.off('close', onClose);\n            ed.setContent(addVisualStyling(ed));\n        };\n        // Add an event listener to the editor to re-add the visual styling when the modal is closed.\n        const observer = new MutationObserver((mutations, obs) => {\n            const viewSrcModal = document.querySelector('[data-region=\"modal\"]');\n            if (viewSrcModal) {\n                viewSrcModal.addEventListener('click', (event) => {\n                    const {action} = event.target.dataset;\n                    if (['cancel', 'save', 'hide'].includes(action)) {\n                        onClose(ed);\n                    }\n                });\n                // Stop observing once the modal is found.\n                obs.disconnect();\n                return;\n            }\n            const tinyMceModal = document.querySelector('.tox-dialog-wrap');\n            if (tinyMceModal) {\n                ed.on('CloseWindow', () => {\n                    onClose(ed);\n                });\n                obs.disconnect();\n            }\n        });\n        observer.observe(document.body, {childList: true, subtree: true});\n        removeVisualStyling(ed);\n    }\n};\n\n/**\n * @param {Editor} ed\n * @param {Node} node\n * @return {{start: Node, end: Node|null}|null}\n */\nconst getNodes = function(ed, node) {\n    // Check if node is a filtercode span.\n    if (!node.classList.contains(classFiltercode) || node.classList.contains(classFiltercodeError)) {\n        return null;\n    }\n    // Get the filtercode key.\n    const key = node.dataset.filtercodekey;\n    // Check if the node is a begin or end span.\n    if (node.classList.contains(classFiltercodeError)\n        || (!node.classList.contains(classFiltercodeBegin) && !node.classList.contains(classFiltercodeEnd))) {\n        return {start: node, end: null};\n    }\n    const isBegin = node.classList.contains(classFiltercodeBegin);\n    // Find all filtercode spans with the same key (begin and end).\n    const partners = ed.dom.select(`.${classFiltercode}[data-filtercodekey=\"${key}\"]`);\n    let currentlevel = 0;\n    let expectedlevel = null;\n    // Find the level of the node.\n    for (const partner of (isBegin ? partners : [...partners].reverse())) {\n        if (partner === node) {\n            expectedlevel = currentlevel;\n            if (partner.classList.contains(classFiltercodeBegin) && !partner.classList.contains(classFiltercodeError)) {\n                currentlevel++;\n            } else if (partner.classList.contains(classFiltercodeEnd) && !partner.classList.contains(classFiltercodeError)) {\n                currentlevel--;\n            }\n            continue;\n        }\n        if (partner.classList.contains(classFiltercodeBegin) && !partner.classList.contains(classFiltercodeError)) {\n            currentlevel++;\n        } else if (partner.classList.contains(classFiltercodeEnd) && !partner.classList.contains(classFiltercodeError)) {\n            currentlevel--;\n        }\n        if (currentlevel === expectedlevel) {\n            return {\n                start: isBegin ? node : partner,\n                end: isBegin ? partner : node,\n            };\n        }\n    }\n\n    return null; // No partner found (possibly imbalanced filtercodes).\n};\n\n/**\n * At the current selection lookup for the current node. If we are inside a special span that encapsulates\n * the {lang} tag, then look for the corresponding opening or closing tag, depending on what's set in the\n * search param.\n * @param {Editor} ed\n * @return {{start: Node, end: Node|null}|null} The encapsulating span tag if found.\n */\nconst getHighlightNodesFromSelect = function(ed) {\n    let nodes = null;\n    ed.dom.getParents(ed.selection.getStart(), elm => {\n        // Are we in a span that highlights the lang tag.\n        if (!isNull(elm.classList) && elm.classList.contains(classFiltercode)) {\n            nodes = getNodes(ed, elm);\n        }\n    });\n\n    return nodes;\n};\n\n/**\n * Check for the parent hierarchy elements, if there's a context toolbar container, then hide it.\n * @param {Node} el\n */\nconst hideContentToolbar = function(el) {\n    while (!isNull(el)) {\n        if (el.nodeType === Node.ELEMENT_NODE &&\n            !isNull(el.getAttribute('class')) &&\n            el.getAttribute('class').indexOf('tox-pop-') != -1\n        ) {\n            el.style.display = 'none';\n            return;\n        }\n        el = el.parentNode;\n    }\n};\n\n/**\n * Check for key press <del> when something is deleted. If that happens inside a highlight span\n * tag, then remove this tag and the corresponding that open/closes this lang tag.\n * @param {Editor} ed\n * @param {Object} event\n */\nexport const onDelete = function(ed, event) {\n    // We are not in composing mode, have not clicked and key <del> or <backspace> was not pressed.\n    if (event.isComposing || (isNull(event.clientX) && event.keyCode !== 46 && event.keyCode !== 8)) {\n        return;\n    }\n    // In case we clicked, check that we clicked an icon (this must have been the trash icon in the context menu).\n    if (!isNull(event.clientX) &&\n        (event.target.nodeType !== Node.ELEMENT_NODE || (event.target.nodeName !== 'path' && event.target.nodeName !== 'svg'))) {\n        return;\n    }\n    // Conditions match either key <del> or <backspace> was pressed, or an click on an svg icon was done.\n    // Check if we are inside a span for the language tag.\n    const nodes = getHighlightNodesFromSelect(ed);\n    // Only if both, start and end tags are found, then delete the nodes here and prevent the default handling\n    // because the stuff to be deleted is already gone.\n    if (!isNull(nodes)) {\n        const {start, end} = nodes;\n        event.preventDefault();\n        ed.dom.remove(start);\n        if (!isNull(end)) {\n            ed.dom.remove(end);\n        }\n        if (!isNull(event.clientX)) {\n            hideContentToolbar(event.target);\n        }\n        // Update color indicators.\n        updateVisualLevelIndicators(ed);\n    }\n};\n\n/**\n * The action when a menu entry is clicked. This adds the tags at the current content\n * position or around the selection.\n * @param {Editor} ed\n * @param {string} filtercodekey\n * @param {Event} event\n */\nexport const applyFiltercode = async function(ed, filtercodekey, event) {\n    if (isNull(filtercodekey)) {\n        return;\n    }\n    const filtercode = filtercodeMap[filtercodekey];\n    if (isNull(filtercode)) {\n        return;\n    }\n    let args = [];\n    if (filtercode.args.length > 0) {\n        args = await openArgumentModal(\n            filtercodekey,\n            filtercode.args.map(() => null)\n        );\n        if (isNull(args)) {\n            return;\n        }\n    }\n    let text = ed.selection.getContent();\n    // Selection is empty, just insert the tag\n    if (text.trim() === '') {\n        // Event is set when the context menu was hit, here the editor lost the previously selected node. Therfore,\n        // don't do anything.\n        if (!isNull(event)) {\n            hideContentToolbar(event.target);\n            return;\n        }\n        if (filtercode.around) {\n            ed.insertContent(filtercode.beginSpan(args).outerHTML + text + filtercode.endSpan().outerHTML);\n        } else {\n            ed.insertContent(filtercode.beginSpan(args).outerHTML);\n        }\n        // Update color indicators.\n        updateVisualLevelIndicators(ed);\n        return;\n    }\n    // // Hide context toolbar, because at any subsequent call the node is not selected anymore.\n    if (!isNull(event)) {\n        hideContentToolbar(event.target);\n    }\n    // No matter if we have syntax highlighting enabled or not, the spans around the tags exist\n    // in the WYSIWYG mode. So check if we are on a special span that encapsulates the tags. Search\n    // for the span tags.\n    const nodes = getHighlightNodesFromSelect(ed);\n    // If we have a span, then it's the opening tag, and we just replace this one with the new filtercode.\n    if (!isNull(nodes)) {\n        const {start, end} = nodes;\n        if (filtercode.around && !isNull(end)) {\n            // Both tags are found and we have a tag that need two tags.\n            const color = start.style.backgroundColor;\n            ed.dom.setOuterHTML(start, filtercode.beginSpan(args, color).outerHTML);\n            ed.dom.setOuterHTML(end, filtercode.endSpan(color).outerHTML);\n            return;\n        }\n        if (!filtercode.around && isNull(end)) {\n            // One tag is found, but the new tag needs only one tag.\n            const color = start.style.backgroundColor;\n            ed.dom.setOuterHTML(start, filtercode.beginSpan(args, color).outerHTML);\n            return;\n        }\n        if (filtercode.around && isNull(end)) {\n            // One tag is found, but the new tag needs two tags.\n            // Replace one tag with two tags.\n            const color = start.style.backgroundColor;\n            ed.dom.setOuterHTML(start, filtercode.beginSpan(args, color).outerHTML + filtercode.endSpan(color).outerHTML);\n            return;\n        }\n        if (!filtercode.around && !isNull(end)) {\n            // Both tags are found and we have a tag that needs only one tag.\n            // Remove the closing tag.\n            const color = start.style.backgroundColor;\n            ed.dom.setOuterHTML(start, filtercode.beginSpan(args, color).outerHTML);\n            ed.dom.remove(end);\n            return;\n        }\n        return;\n    }\n    // Not inside a tag, insert a new opening and closing tag with the selection inside.\n    if (filtercode.around) {\n        ed.insertContent(filtercode.beginSpan(args).outerHTML + text + filtercode.endSpan().outerHTML);\n    } else {\n        ed.insertContent(filtercode.beginSpan(args).outerHTML);\n    }\n    // Update color indicators.\n    updateVisualLevelIndicators(ed);\n};\n\nexport const onEdit = async function(ed, event) {\n    // Check if we are inside a span for the language tag.\n    const nodes = getHighlightNodesFromSelect(ed);\n    // Only if both, start and end tags are found, then delete the nodes here and prevent the default handling\n    // because the stuff to be deleted is already gone.\n    if (!isNull(nodes)) {\n        const {start} = nodes;\n        event.preventDefault();\n        const filtercodekey = start.dataset.filtercodekey;\n        if (isNull(filtercodekey)) {\n            return;\n        }\n        const filtercode = filtercodeMap[filtercodekey];\n        if (isNull(filtercode) || filtercode.args.length === 0) {\n            // We don't know the filtercode, so we can't edit it.\n            return;\n        }\n        let args = start.dataset.filtercodeargs.split(' ');\n        args = await openArgumentModal(filtercodekey, args);\n        if (isNull(args)) {\n            return;\n        }\n        ed.dom.setOuterHTML(start, filtercode.beginSpan(args).outerHTML);\n        updateVisualLevelIndicators(ed);\n    }\n};\n"],"names":["_isSubmit","transformDomToSpan","node","newchildren","childNodes","forEach","child","nodeType","Node","TEXT_NODE","push","input","textContent","output","echo","text","length","document","createTextNode","start","search","regexTagStartEnd","substring","match","matchAll","next","value","isClosing","key","args","filtercode","filtercodeMap","around","endSpan","beginSpan","replace","split","replaceTextWithSpan","ELEMENT_NODE","classList","contains","classFiltercode","innerHTML","appendChild","addVisualStyling","ed","getContent","element","DOMParser","parseFromString","body","addVisualLevelIndicators","el","keyStack","spans","querySelectorAll","span","filter","className","remove","classFiltercodeError","classFiltercodeBegin","classFiltercodeEnd","top","dataset","filtercodekey","find","begin","add","pop","updateVisualLevelIndicators","dom","select","removeClass","addClass","setContent","addStyle","removeVisualStyling","setOuterHTML","save","no_events","content","source_view","onClose","off","MutationObserver","mutations","obs","viewSrcModal","querySelector","addEventListener","event","action","target","includes","disconnect","on","observe","childList","subtree","getHighlightNodesFromSelect","nodes","getParents","selection","getStart","elm","end","isBegin","partners","currentlevel","expectedlevel","partner","reverse","getNodes","hideContentToolbar","getAttribute","indexOf","style","display","parentNode","isComposing","clientX","keyCode","nodeName","preventDefault","async","map","trim","insertContent","outerHTML","color","backgroundColor","filtercodeargs"],"mappings":"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"}